/**
 * cabin-framework (https://github.com/anpydx/cabin)
 *
 * Copyright (c) 2025 anpyd, All Rights Reserved.
 * Licensed under the MIT License.
 */

#pragma once
#include <glm/glm.hpp>
#include <GLFW/glfw3.h>

namespace cabin::utils {

    /** FPS Style Camera
     * 
     * -----------------------------------
     * `Camera` is utility class for user to create a FPS 
     *  Camera in their sandbox application.
     *
     *  It cooperates well with applications using GLFW and GLM.
     *
     *  To integrate camera in your sandbox application, you
     *  need to call `updateInput` and `mouseButtonCallback`
     *  in appropriate positions. 
     *
     *  @see Usage example:
     *        sandbox/hello_triangle/main.cc
     *
     *  @note
     *  Camera coordinate follows Right-handed System.
     */
    class Camera {
    public:
        
        /** Construct a new Camera object.
         * 
         * @param position Camera's position.
         * @param front    Camera's front direction.
         * @param up       Camera's up direction.
         */
        Camera(const glm::vec3& position, const glm::vec3& front, const glm::vec3 up);

        /** Set the view sensitivity.
         * 
         * @param sensitivity
         */
        void setSensitivity(float sensitivity);

        /** Set the maximum movement speed of camera.
         * 
         * @param speed 
         */
        void setSpeedMaximum(const glm::vec2& speed);

        /** Set the movement acceleration of camera.
         * 
         * @param acceleration 
         */
        void setAcceleration(const glm::vec2& acceleration);

        /** Set the camera's position.
         * 
         * @param position 
         */
        void setPosition(const glm::vec3& position);

        /** Set the camera's `front` direction.
         * 
         * @param front The front direction of camera.
         *
         * @note  Camera coordinate system will be rebuilt.
         *        
         *        The `left` direction will be produced by `corss({ 0.0, 1.0, 0.0 }, front)`,
         *        which means `left` is always perpendicular to the world Y-axis.
         *         
         *        To fully customize camera's roll angle, 
         *        use `void setDirection(const glm::vec3& front, const glm::vec3& up)` inside.
         */
        void setDirection(const glm::vec3& front);

        /** Set the camera's `front` and `up` direction.
         * 
         * @param front The front direction of camera.
         * @param up    The up direction of camera.
         *
         * @note  Camera coordinate system will be rebuilt.
         */
        void setDirection(const glm::vec3& front, const glm::vec3& up);

        /** Update the keyboard input and cursor position.
         *
         *  Where camera movement and view rotation occurred.
         * 
         * @param window GLFWwindow handle of sandbox application.
         *
         * @note Function should be called every render loop.
         *
         *       There is speed compensation caused by tick-rate(or FPS) differences.
         *
         * @see Usage example:
         *       sandbox/hello_triangle/main.cc
         */
        void updateInput(GLFWwindow* window);


        /** Mouse button callback function.
         * 
         * @param window GLFWinwdow handle.
         * @param button Mouse button's name.
         * @param action Mouse button's action.
         *
         * @note Should be called in callback function 
         *       setted by `glfwSetMouseButtonCallback`.
         */
        void mouseButtonCallback(GLFWwindow* window, int button, int action);

        /** Get speed components' intensity of camera.
         * 
         * @note Relationship between speed and velocity
         *       `velocity = speed.x * front + speed.y * left`
         */
        [[nodiscard]]
        glm::vec2 getSpeed() const;

        /** Get the volecity of camera.
         *
         * @note Relationship between speed and velocity
         *       `velocity = speed.x * front + speed.y * left`
         */
        [[nodiscard]]
        glm::vec3 getVolecity() const;

        //! Returns the normalized front direction of camera.
        [[nodiscard]]
        glm::vec3 getFrontDirecction() const;

        //! Returns the normalized left direction of camera.
        [[nodiscard]]
        glm::vec3 getLeftDirection() const;

        //! Returns the normalized up direction of camera.
        [[nodiscard]]
        glm::vec3 getUpDirection() const;

        //! Returns the LookAt matrix generated by camera.
        [[nodiscard]]
        glm::mat4 getLookAt() const;

    private:
        void setCursorOrigin(const glm::vec2& position);
    
    public:
        bool cursorCaptured { false };
        float sensitivity { 2.0f };
        glm::vec2 speedMaximum { 3.0f };
        glm::vec2 acceleration { 0.1f };
        glm::vec3 position { 0.0f };

    private:
        glm::vec2 m_speed { 0.0f };
        glm::vec2 m_cursorOrigin { 0.0f };

        glm::vec3 m_upDirection;
        glm::vec3 m_leftDirection;
        glm::vec3 m_frontDirection;

        glm::vec3 m_upDirectionBase;
        glm::vec3 m_leftDirectionBase;
        glm::vec3 m_frontDirectionBase;
    };
}